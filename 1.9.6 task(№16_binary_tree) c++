#include <iostream>
#include <stack>
#include <queue>

using namespace std;

// Структура узла бинарного дерева
struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}
};

class BinaryTree {
private:
    TreeNode* root;

public:
    BinaryTree() : root(nullptr) {}

    // Вставка элемента в дерево (простая реализация для демонстрации)
    void insert(int val) {
        if (root == nullptr) {
            root = new TreeNode(val);
            return;
        }

        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            TreeNode* current = q.front();
            q.pop();

            if (current->left == nullptr) {
                current->left = new TreeNode(val);
                return;
            } else {
                q.push(current->left);
            }

            if (current->right == nullptr) {
                current->right = new TreeNode(val);
                return;
            } else {
                q.push(current->right);
            }
        }
    }

    // Preorder обход (корень -> левый -> правый) - рекурсивно
    void preorderRecursive(TreeNode* node) {
        if (node == nullptr) return;

        cout << node->data << " ";  // Посетить корень
        preorderRecursive(node->left);  // Обойти левое поддерево
        preorderRecursive(node->right); // Обойти правое поддерево
    }

    // Preorder обход - итеративно
    void preorderIterative() {
        if (root == nullptr) return;

        stack<TreeNode*> st;
        st.push(root);

        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();

            cout << node->data << " ";

            // Сначала правый, потом левый (чтобы левый обрабатывался первым в стеке)
            if (node->right != nullptr) {
                st.push(node->right);
            }
            if (node->left != nullptr) {
                st.push(node->left);
            }
        }
    }

    // Inorder обход (левый -> корень -> правый) - рекурсивно
    void inorderRecursive(TreeNode* node) {
        if (node == nullptr) return;

        inorderRecursive(node->left);   // Обойти левое поддерево
        cout << node->data << " ";      // Посетить корень
        inorderRecursive(node->right);  // Обойти правое поддерево
    }

    // Inorder обход - итеративно
    void inorderIterative() {
        stack<TreeNode*> st;
        TreeNode* current = root;

        while (current != nullptr || !st.empty()) {
            // Дойти до самого левого узла
            while (current != nullptr) {
                st.push(current);
                current = current->left;
            }

            // current теперь nullptr, берем из стека
            current = st.top();
            st.pop();

            cout << current->data << " ";

            // Переходим к правому поддереву
            current = current->right;
        }
    }

    // Postorder обход (левый -> правый -> корень) - рекурсивно
    void postorderRecursive(TreeNode* node) {
        if (node == nullptr) return;

        postorderRecursive(node->left);   // Обойти левое поддерево
        postorderRecursive(node->right);  // Обойти правое поддерево
        cout << node->data << " ";        // Посетить корень
    }

    // Postorder обход - итеративно (с двумя стеками)
    void postorderIterative() {
        if (root == nullptr) return;

        stack<TreeNode*> st1, st2;
        st1.push(root);

        while (!st1.empty()) {
            TreeNode* node = st1.top();
            st1.pop();
            st2.push(node);

            if (node->left != nullptr) {
                st1.push(node->left);
            }
            if (node->right != nullptr) {
                st1.push(node->right);
            }
        }

        // Выводим элементы из второго стека
        while (!st2.empty()) {
            cout << st2.top()->data << " ";
            st2.pop();
        }
    }

    // Обертки для рекурсивных методов
    void printPreorder() {
        cout << "Preorder (рекурсивно): ";
        preorderRecursive(root);
        cout << endl;

        cout << "Preorder (итеративно):  ";
        preorderIterative();
        cout << endl;
    }

    void printInorder() {
        cout << "Inorder (рекурсивно):  ";
        inorderRecursive(root);
        cout << endl;

        cout << "Inorder (итеративно):   ";
        inorderIterative();
        cout << endl;
    }

    void printPostorder() {
        cout << "Postorder (рекурсивно): ";
        postorderRecursive(root);
        cout << endl;

        cout << "Postorder (итеративно):  ";
        postorderIterative();
        cout << endl;
    }

    // Создание примера дерева
    void createExampleTree() {
        // Создаем дерево:
        //       1
        //      / \
        //     2   3
        //    / \   \
        //   4   5   6
        //      /
        //     7

        root = new TreeNode(1);
        root->left = new TreeNode(2);
        root->right = new TreeNode(3);
        root->left->left = new TreeNode(4);
        root->left->right = new TreeNode(5);
        root->right->right = new TreeNode(6);
        root->left->right->left = new TreeNode(7);
    }

    // Очистка памяти (деструктор)
    ~BinaryTree() {
        clearTree(root);
    }

private:
    void clearTree(TreeNode* node) {
        if (node == nullptr) return;

        clearTree(node->left);
        clearTree(node->right);
        delete node;
    }
};

int main() {
    BinaryTree tree;

    // пример дерева
    tree.createExampleTree();

    cout << "              1" << endl;
    cout << "             / \\" << endl;
    cout << "            2   3" << endl;
    cout << "           / \\   \\" << endl;
    cout << "          4   5   6" << endl;
    cout << "             /" << endl;
    cout << "            7" << endl << endl;

    // Preorder обход (корень -> левый -> правый)
    tree.printPreorder();
    cout << endl;
    // Inorder обход (левый -> корень -> правый)
    tree.printInorder();
    cout << endl;
    // Postorder обход (левый -> правый -> корень)
    tree.printPostorder();
    cout << endl;

    return 0;
}
