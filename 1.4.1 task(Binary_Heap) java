import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;

// Реализация бинарной кучи (по умолчанию max-heap)
public class BinaryHeap<E> {
    private final List<E> data = new ArrayList<>(); // массив для хранения
    private final Comparator<? super E> cmp;        // компаратор (может быть null)

    public BinaryHeap() {
        this.cmp = null; // будет использовать natural ordering (Comparable)
    }
    public BinaryHeap(Comparator<? super E> cmp) {
        this.cmp = cmp;
    }
    public BinaryHeap(Collection<? extends E> coll, Comparator<? super E> cmp) {
        this.cmp = cmp;
        data.addAll(coll);
        // Построение кучи за O(n)
        for (int i = parent(data.size() - 1); i >= 0; i--) siftDown(i);
    }

    // Добавление элемента за O(log n)
    public void add(E value) {
        Objects.requireNonNull(value);
        data.add(value);
        siftUp(data.size() - 1);
    }

    // Доступ к корню
    public E peek() {
        if (data.isEmpty()) return null;
        return data.get(0);
    }

    // Извлечение корня за O(log n)
    public E poll() {
        if (data.isEmpty()) return null;
        E res = data.get(0);
        E last = data.remove(data.size() - 1);
        if (!data.isEmpty()) {
            data.set(0, last);
            siftDown(0);
        }
        return res;
    }

    public int size() { return data.size(); }
    public boolean isEmpty() { return data.isEmpty(); }

    @SuppressWarnings("unchecked")
    private int compare(E a, E b) {
        if (cmp != null) return cmp.compare(a,b);
        return ((Comparable<? super E>)a).compareTo(b);
    }

    // Просеивание вверх
    private void siftUp(int idx) {
        while (idx > 0) {
            int p = parent(idx);
            if (compare(data.get(p), data.get(idx)) >= 0) break;
            swap(p, idx);
            idx = p;
        }
    }

    // Просеивание вниз
    private void siftDown(int idx) {
        int n = data.size();
        while (true) {
            int l = left(idx);
            int r = l + 1;
            int largest = idx;
            if (l < n && compare(data.get(l), data.get(largest)) > 0) largest = l;
            if (r < n && compare(data.get(r), data.get(largest)) > 0) largest = r;
            if (largest == idx) break;
            swap(idx, largest);
            idx = largest;
        }
    }

    private void swap(int i, int j) {
        E tmp = data.get(i); data.set(i, data.get(j)); data.set(j, tmp);
    }
    private int parent(int i) { return (i - 1) / 2; }
    private int left(int i) { return i * 2 + 1; }
}
/*
public class Demo {
    public static void main(String[] args) {
        // Max-heap (по умолчанию)
        BinaryHeap<Integer> heap = new BinaryHeap<>();
        heap.add(3); heap.add(1); heap.add(4); heap.add(1); heap.add(5);
        while (!heap.isEmpty()) {
            System.out.print(heap.poll() + " ");
        }
        System.out.println();

        // Min-heap: передаём обратный компаратор
        BinaryHeap<Integer> minHeap = new BinaryHeap<>((a,b) -> Integer.compare(b,a));
        minHeap.add(10); minHeap.add(2); minHeap.add(7);
        while (!minHeap.isEmpty()) System.out.print(minHeap.poll() + " ");
    }
}
*/
